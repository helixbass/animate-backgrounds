// Generated by CoffeeScript 1.12.5
(function() {
  var Color, Tween, _int, color_eq, color_regex_chunk, extend, extended, gradient_handler, is_string, length_regex_chunk, map, parse_linear_gradient, parse_radial_gradient, pre_stops_css_linear_gradient, pre_stops_css_radial_gradient, regex_chunk_str, register_animation_handler, scaled,
    slice = [].slice;

  extend = $.extend, Tween = $.Tween, Color = $.Color;

  is_string = function(obj) {
    return 'string' === $.type(obj);
  };

  map = function(arr, clb) {
    var elem, i, j, len, results;
    results = [];
    for (i = j = 0, len = arr.length; j < len; i = ++j) {
      elem = arr[i];
      results.push(clb(elem, i));
    }
    return results;
  };

  extended = function() {
    var obj, objs;
    obj = arguments[0], objs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return extend.apply(null, [{}, obj].concat(slice.call(objs)));
  };

  register_animation_handler = function(arg) {
    var css_val_from_initialized_tween, hook_name, init, init_tween_end, parse, parsed_tween, prop_name;
    prop_name = arg.prop_name, hook_name = arg.hook_name, parse = arg.parse, init_tween_end = arg.init_tween_end, css_val_from_initialized_tween = arg.css_val_from_initialized_tween;
    parsed_tween = function(tween) {
      return parse($(tween.elem).css(prop_name));
    };
    init = function(tween) {
      tween.start = parsed_tween(tween);
      tween.end = init_tween_end({
        tween: tween,
        parse: parse
      });
      tween.set = true;
      return console.log({
        tween: tween
      });
    };
    return Tween.propHooks[hook_name != null ? hook_name : prop_name] = {
      get: parsed_tween,
      set: function(tween) {
        if (!tween.set) {
          init(tween);
        }
        return $(tween.elem).css(prop_name, css_val_from_initialized_tween({
          tween: tween,
          parsed_tween: parsed_tween
        }));
      }
    };
  };

  register_animation_handler({
    prop_name: 'backgroundPosition',
    parse: function(val) {
      var _match, bg, dim, dims, j, len, ref, results;
      ref = (val || '').split(/\s*,\s*/);
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        bg = ref[j];
        dims = (function() {
          var ref1, unstandardizedDims;
          unstandardizedDims = bg.split(/\s+/);
          if (unstandardizedDims.length === 1) {
            unstandardizedDims = (ref1 = unstandardizedDims[0]) === 'top' || ref1 === 'bottom' ? ['50%', unstandardizedDims[0]] : [unstandardizedDims[0], '50%'];
          }
          return map(unstandardizedDims, function(dim) {
            var presets;
            presets = {
              center: '50%',
              left: '0%',
              right: '100%',
              top: '0%',
              bottom: '100%'
            };
            return "" + (presets[dim] || dim);
          });
        })();
        results.push((function() {
          var k, len1, results1;
          results1 = [];
          for (k = 0, len1 = dims.length; k < len1; k++) {
            dim = dims[k];
            _match = dim.match(/^([+-]=)?([+-]?\d+(?:\.\d*)?)(.*)$/);
            results1.push({
              rel_op: _match[1],
              amount: parseFloat(_match[2]),
              unit: _match[3] || 'px'
            });
          }
          return results1;
        })());
      }
      return results;
    },
    init_tween_end: function(arg) {
      var bgIndex, end, endBg, j, len, parse, ref, results, start, tween;
      tween = arg.tween, parse = arg.parse;
      start = tween.start, end = tween.end;
      ref = parse(end);
      results = [];
      for (bgIndex = j = 0, len = ref.length; j < len; bgIndex = ++j) {
        endBg = ref[bgIndex];
        results.push(map(endBg, function(val, i) {
          var amount, rel_op;
          rel_op = val.rel_op, amount = val.amount;
          if (!rel_op) {
            return val;
          }
          val.amount = start[bgIndex][i].amount + amount * (rel_op === '-=' ? -1 : 1);
          return val;
        }));
      }
      return results;
    },
    css_val_from_initialized_tween: function(arg) {
      var _adjusted, _span, bgEnd, bgIndex, bgStart, dim, end, pos, start, tween;
      tween = arg.tween;
      pos = tween.pos, start = tween.start, end = tween.end;
      return ((function() {
        var j, len, results;
        results = [];
        for (bgIndex = j = 0, len = start.length; j < len; bgIndex = ++j) {
          bgStart = start[bgIndex];
          bgEnd = end[bgIndex];
          _span = function(dim) {
            return bgEnd[dim].amount - bgStart[dim].amount;
          };
          _adjusted = function(dim) {
            return bgStart[dim].amount + pos * _span(dim);
          };
          results.push(((function() {
            var k, len1, ref, results1;
            ref = [0, 1];
            results1 = [];
            for (k = 0, len1 = ref.length; k < len1; k++) {
              dim = ref[k];
              results1.push("" + (_adjusted(dim)) + bgStart[dim].unit);
            }
            return results1;
          })()).join(' '));
        }
        return results;
      })()).join(', ');
    }
  });

  register_animation_handler({
    prop_name: 'backgroundSize',
    parse: function(val) {
      var _match, bg, dim, dims, j, len, ref, results;
      ref = (val || '').split(/\s*,\s*/);
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        bg = ref[j];
        dims = (function() {
          var suppliedDims;
          if (bg === 'contain' || bg === 'cover') {
            return [bg, ''];
          }
          suppliedDims = bg.split(/\s+/);
          if (suppliedDims.length !== 1) {
            return suppliedDims;
          }
          return [suppliedDims[0], 'auto'];
        })();
        results.push((function() {
          var k, len1, results1;
          results1 = [];
          for (k = 0, len1 = dims.length; k < len1; k++) {
            dim = dims[k];
            _match = dim.match(/^(?:(?:([+-]=)?([+-]?\d+(?:\.\d*)?)(.*))|auto)$/);
            if (!(_match != null ? _match[2] : void 0)) {
              results1.push(dim);
            } else {
              results1.push({
                rel_op: _match[1],
                amount: parseFloat(_match[2]),
                unit: _match[3] || 'px'
              });
            }
          }
          return results1;
        })());
      }
      return results;
    },
    init_tween_end: function(arg) {
      var bgIndex, end, endBg, j, len, parse, ref, results, start, tween;
      tween = arg.tween, parse = arg.parse;
      start = tween.start, end = tween.end;
      ref = parse(end);
      results = [];
      for (bgIndex = j = 0, len = ref.length; j < len; bgIndex = ++j) {
        endBg = ref[bgIndex];
        results.push(map(endBg, function(val, i) {
          var amount, rel_op;
          if (!(val != null ? val.unit : void 0)) {
            return val;
          }
          rel_op = val.rel_op, amount = val.amount;
          if (!rel_op) {
            return val;
          }
          val.amount = start[bgIndex][i].amount + amount * (rel_op === '-=' ? -1 : 1);
          return val;
        }));
      }
      return results;
    },
    css_val_from_initialized_tween: function(arg) {
      var _adjusted, _span, bgEnd, bgIndex, bgStart, bgStartDim, dim, end, pos, start, tween;
      tween = arg.tween;
      pos = tween.pos, start = tween.start, end = tween.end;
      return ((function() {
        var j, len, results;
        results = [];
        for (bgIndex = j = 0, len = start.length; j < len; bgIndex = ++j) {
          bgStart = start[bgIndex];
          bgEnd = end[bgIndex];
          _span = function(dim) {
            return bgEnd[dim].amount - bgStart[dim].amount;
          };
          _adjusted = function(dim) {
            return bgStart[dim].amount + pos * _span(dim);
          };
          results.push(((function() {
            var k, len1, ref, results1;
            ref = [0, 1];
            results1 = [];
            for (k = 0, len1 = ref.length; k < len1; k++) {
              dim = ref[k];
              bgStartDim = bgStart[dim];
              if (bgStartDim != null ? bgStartDim.unit : void 0) {
                results1.push("" + (_adjusted(dim)) + bgStartDim.unit);
              } else {
                results1.push(bgStartDim);
              }
            }
            return results1;
          })()).join(' ').trim());
        }
        return results;
      })()).join(', ');
    }
  });

  _int = function(str) {
    return parseInt(str, 10);
  };

  regex_chunk_str = function(regex) {
    var all, chunk, ref;
    ref = /^\/(.*)\/[^\/]*$/.exec(regex.toString()), all = ref[0], chunk = ref[1];
    return chunk;
  };

  length_regex_chunk = regex_chunk_str(/(?:([0-9.]+)(%|\w+))/);

  color_regex_chunk = regex_chunk_str(/((?:rgba?\([^)]*\))|(?:hsla?\([^)]*\))|(?:\#[0-9A-Fa-f]+)|\w+)/);

  scaled = function(arg) {
    var end, pos, prop, start, val;
    start = arg.start, end = arg.end, pos = arg.pos, prop = arg.prop;
    if (prop) {
      if (is_string(prop)) {
        prop = (function(prop) {
          return function(val) {
            return val[prop];
          };
        })(prop);
      }
      start = prop(start);
      end = prop(end);
    }
    val = start + pos * (end - start);
    return val;
  };

  color_eq = function(a, b) {
    var component, component_index, j, len, ref;
    if (!(a instanceof Color)) {
      a = Color(a);
    }
    if (!(b instanceof Color)) {
      b = Color(b);
    }
    ref = a._rgba;
    for (component_index = j = 0, len = ref.length; j < len; component_index = ++j) {
      component = ref[component_index];
      if (b._rgba[component_index] !== component) {
        return false;
      }
    }
    return true;
  };

  gradient_handler = function(arg) {
    var function_name, hook_name, parse_gradient, pre_stops_css;
    function_name = arg.function_name, hook_name = arg.hook_name, parse_gradient = arg.parse_gradient, pre_stops_css = arg.pre_stops_css;
    return {
      hook_name: hook_name,
      prop_name: 'backgroundImage',
      init_tween_end: function(arg1) {
        var changing_vals, end, looks_like_shorthand, parse, start, tween;
        tween = arg1.tween, parse = arg1.parse;
        start = tween.start, end = tween.end;
        looks_like_shorthand = function(end) {
          if (RegExp("\\s*(?:" + length_regex_chunk + "|" + color_regex_chunk + ")\\s*->").exec(end)) {
            return true;
          }
        };
        if (!looks_like_shorthand(end)) {
          return parse(end);
        }
        changing_vals = (function() {
          var all, color, match, pair, parsed_pairs, position, remaining, separator, unit;
          parsed_pairs = [];
          separator = null;
          remaining = end;
          while (remaining) {
            match = RegExp("^\\s*(?:" + length_regex_chunk + "|" + color_regex_chunk + ")\\s*->\\s*").exec(remaining);
            all = match[0], position = match[1], unit = match[2], color = match[3];
            pair = color != null ? {
              type: 'color',
              start: {
                color: color
              }
            } : {
              type: 'length',
              start: {
                unit: unit,
                position: _int(position)
              }
            };
            remaining = remaining.slice(all.length);
            match = RegExp("^(?:" + length_regex_chunk + "|" + color_regex_chunk + ")[^,\\n\\S]*([,\\n])\\s*").exec(remaining);
            all = match[0], position = match[1], unit = match[2], color = match[3], separator = match[4];
            pair.end = color != null ? {
              color: color
            } : {
              unit: unit,
              position: _int(position)
            };
            parsed_pairs.push(pair);
            remaining = remaining.slice(all.length);
          }
          return parsed_pairs;
        })();
        return {
          _change: (function() {
            var _change, angle, base, changed, changed_stop, color, image, image_index, j, k, l, len, len1, len2, position, ref, stop, stop_index, stops, type, unit;
            _change = [];
            for (image_index = j = 0, len = start.length; j < len; image_index = ++j) {
              image = start[image_index];
              if (is_string(image)) {
                continue;
              }
              stops = image.stops, angle = image.angle;
              changed = null;
              for (stop_index = k = 0, len1 = stops.length; k < len1; stop_index = ++k) {
                stop = stops[stop_index];
                changed_stop = null;
                for (l = 0, len2 = changing_vals.length; l < len2; l++) {
                  ref = changing_vals[l], start = ref.start, end = ref.end, type = ref.type;
                  switch (type) {
                    case 'length':
                      position = start.position, unit = start.unit;
                      if (!(position === stop.position && unit === stop.unit)) {
                        continue;
                      }
                      extend((changed_stop != null ? changed_stop : changed_stop = {}), {
                        position: end.position,
                        unit: end.unit
                      });
                      break;
                    case 'color':
                      color = start.color;
                      if (!color_eq(color, stop.color)) {
                        continue;
                      }
                      extend((changed_stop != null ? changed_stop : changed_stop = {}), {
                        color: end.color
                      });
                  }
                }
                ((base = (changed != null ? changed : changed = {})).stops != null ? base.stops : base.stops = [])[stop_index] = changed_stop;
              }
              if (changed) {
                _change[image_index] = changed;
              }
            }
            return _change;
          })()
        };
      },
      parse: function(val) {
        var _top_level_args, image, j, len, ref, results;
        _top_level_args = function(val) {
          return val.match(/[^\(,]*\((?:[^\(\)]+|[^\(\)]+\([^\)]+\)[^\(\)]*)+\)[^,]*|[^,]+/g);
        };
        ref = _top_level_args(val);
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          image = ref[j];
          results.push((function() {
            var obj, parsed, stops_str;
            parsed = parse_gradient({
              image: image,
              function_name: function_name
            });
            if (!(parsed != null ? parsed.stops_str : void 0)) {
              return parsed;
            }
            stops_str = parsed.stops_str, obj = parsed.obj;
            return extended(obj, {
              stops: (function() {
                var all, assign_missing_stop_positions, color, fill_consecutive_missing_stop_positions, fill_in_missing, match, position, split_stops, stop, stop_index, stops, unit;
                split_stops = _top_level_args(stops_str);
                stops = (function() {
                  var k, len1, results1;
                  results1 = [];
                  for (stop_index = k = 0, len1 = split_stops.length; k < len1; stop_index = ++k) {
                    stop = split_stops[stop_index];
                    match = RegExp("^\\s*" + color_regex_chunk + "(?:\\s+" + length_regex_chunk + ")?").exec(stop);
                    all = match[0], color = match[1], position = match[2], unit = match[3];
                    if (position == null) {
                      position = (function() {
                        switch (stop_index) {
                          case 0:
                            return 0;
                          case split_stops.length - 1:
                            return 100;
                        }
                      })();
                      unit = '%';
                    }
                    results1.push({
                      color: Color(color),
                      position: position != null ? _int(position) : void 0,
                      unit: unit != null ? unit : 'px'
                    });
                  }
                  return results1;
                })();
                fill_in_missing = function(arg1) {
                  var current_position, following_stop_position, k, len1, missing, missing_stop, per, prev_stop_position, results1;
                  missing = arg1.missing, prev_stop_position = arg1.prev_stop_position, following_stop_position = arg1.following_stop_position;
                  per = (following_stop_position - prev_stop_position) / (missing.length + 1);
                  current_position = prev_stop_position;
                  results1 = [];
                  for (k = 0, len1 = missing.length; k < len1; k++) {
                    missing_stop = missing[k];
                    current_position += per;
                    results1.push(missing_stop.position = current_position);
                  }
                  return results1;
                };
                assign_missing_stop_positions = function(arg1) {
                  var following_stop, following_stop_index, k, len1, missing, prev_stop_position, ref1, stop_index;
                  stop_index = arg1.stop_index, prev_stop_position = arg1.prev_stop_position;
                  missing = [stop];
                  ref1 = stops.slice(stop_index + 1);
                  for (following_stop_index = k = 0, len1 = ref1.length; k < len1; following_stop_index = ++k) {
                    following_stop = ref1[following_stop_index];
                    position = following_stop.position;
                    if (position != null) {
                      fill_in_missing({
                        missing: missing,
                        prev_stop_position: prev_stop_position,
                        following_stop_position: position
                      });
                      return stop_index + following_stop_index + 1;
                    } else {
                      missing.push(following_stop);
                    }
                  }
                };
                fill_consecutive_missing_stop_positions = function() {
                  var k, len1, prev_stop_position;
                  prev_stop_position = null;
                  for (stop_index = k = 0, len1 = stops.length; k < len1; stop_index = ++k) {
                    stop = stops[stop_index];
                    position = stop.position;
                    if (position == null) {
                      return assign_missing_stop_positions({
                        stop: stop,
                        stop_index: stop_index,
                        prev_stop_position: prev_stop_position
                      });
                    }
                    prev_stop_position = position;
                  }
                  return null;
                };
                while (fill_consecutive_missing_stop_positions()) {
                  null;
                }
                return stops;
              })()
            });
          })());
        }
        return results;
      },
      css_val_from_initialized_tween: function(arg1) {
        var _change, current, end, image, image_index, parsed_tween, pos, start, tween;
        tween = arg1.tween, parsed_tween = arg1.parsed_tween;
        pos = tween.pos, start = tween.start, end = tween.end;
        _change = end._change;
        current = null;
        return ((function() {
          var j, len, results;
          results = [];
          for (image_index = j = 0, len = start.length; j < len; image_index = ++j) {
            image = start[image_index];
            results.push((function() {
              var _scaled, adjusted_stops, color, color_change, current_image, current_stop, end_change, end_image, position, position_change, stop, stop_change, stop_index, unit;
              if (is_string(image)) {
                return image;
              }
              if (_change && !(end_change = _change[image_index])) {
                return image;
              }
              if (end_change) {
                current_image = (current != null ? current : current = parsed_tween(tween))[image_index];
              }
              end_image = end[image_index];
              _scaled = function(prop) {
                return scaled({
                  start: image,
                  end: end_image,
                  pos: pos,
                  prop: prop
                });
              };
              adjusted_stops = (function() {
                var k, len1, ref, ref1, results1;
                ref = image.stops;
                results1 = [];
                for (stop_index = k = 0, len1 = ref.length; k < len1; stop_index = ++k) {
                  stop = ref[stop_index];
                  color = stop.color, unit = stop.unit, position = stop.position;
                  if (end_change) {
                    current_stop = current_image.stops[stop_index];
                    if (stop_change = (ref1 = end_change.stops) != null ? ref1[stop_index] : void 0) {
                      results1.push({
                        color: (color_change = stop_change.color) ? color.transition(color_change, pos) : current_stop.color,
                        position: (position_change = stop_change.position) ? scaled({
                          start: position,
                          end: position_change,
                          pos: pos
                        }) : current_stop.position,
                        unit: unit
                      });
                    } else {
                      results1.push(current_stop);
                    }
                  } else {
                    results1.push({
                      color: color.transition(end_image.stops[stop_index].color, pos),
                      position: _scaled(function(arg2) {
                        var stops;
                        stops = arg2.stops;
                        return stops[stop_index].position;
                      }),
                      unit: unit
                    });
                  }
                }
                return results1;
              })();
              return function_name + "(" + (pre_stops_css({
                start_gradient: image,
                end_gradient: end_image,
                end_change: end_change,
                pos: pos
              })) + (((function() {
                var k, len1, ref, results1;
                results1 = [];
                for (k = 0, len1 = adjusted_stops.length; k < len1; k++) {
                  ref = adjusted_stops[k], color = ref.color, position = ref.position, unit = ref.unit;
                  results1.push(color + " " + position + unit);
                }
                return results1;
              })()).join(', ')) + ")";
            })());
          }
          return results;
        })()).join(', ');
      }
    };
  };

  parse_linear_gradient = function(arg) {
    var all, angle, first_direction, function_name, image, match, second_direction, stops_str;
    image = arg.image, function_name = arg.function_name;
    match = RegExp("^\\s*" + function_name + "\\(\\s*(?:(?:(-?\\d+)deg|to\\s+(bottom|top|left|right)(?:\\s+(bottom|top|left|right))?)\\s*,\\s*)?(.+)\\)\\s*$").exec(image);
    if (!match) {
      return image;
    }
    all = match[0], angle = match[1], first_direction = match[2], second_direction = match[3], stops_str = match[4];
    return {
      obj: {
        angle: (function() {
          if (angle) {
            return _int(angle);
          }
          if (second_direction) {
            if ('top' === first_direction || 'top' === second_direction) {
              if ('left' === first_direction || 'left' === second_direction) {
                return 315;
              } else {
                return 45;
              }
            } else {
              if ('left' === first_direction || 'left' === second_direction) {
                return 225;
              } else {
                return 135;
              }
            }
          } else {
            return (function() {
              if (!first_direction) {
                first_direction = 'bottom';
              }
              switch (first_direction) {
                case 'top':
                  return 0;
                case 'bottom':
                  return 180;
                case 'left':
                  return 270;
                case 'right':
                  return 90;
              }
            })();
          }
        })()
      },
      stops_str: stops_str
    };
  };

  pre_stops_css_linear_gradient = function(arg) {
    var end_change, end_gradient, pos, start_gradient;
    start_gradient = arg.start_gradient, end_gradient = arg.end_gradient, end_change = arg.end_change, pos = arg.pos;
    return (end_change ? start_gradient.angle : scaled({
      start: start_gradient,
      end: end_gradient,
      pos: pos,
      prop: 'angle'
    })) + "deg, ";
  };

  register_animation_handler(gradient_handler({
    hook_name: 'linearGradient',
    function_name: 'linear-gradient',
    parse_gradient: parse_linear_gradient,
    pre_stops_css: pre_stops_css_linear_gradient
  }));

  register_animation_handler(gradient_handler({
    hook_name: 'repeatingLinearGradient',
    function_name: 'repeating-linear-gradient',
    parse_gradient: parse_linear_gradient,
    pre_stops_css: pre_stops_css_linear_gradient
  }));

  parse_radial_gradient = function(arg) {
    var all, function_name, image, match, shape, stops_str;
    image = arg.image, function_name = arg.function_name;
    match = RegExp("^\\s*" + function_name + "\\(\\s*(?:(circle|ellipse)\\s*,\\s*)?(.+)\\)\\s*$").exec(image);
    if (!match) {
      return image;
    }
    all = match[0], shape = match[1], stops_str = match[2];
    return {
      obj: {
        shape: shape
      },
      stops_str: stops_str
    };
  };

  pre_stops_css_radial_gradient = function(arg) {
    var end_change, end_gradient, pos, shape, start_gradient;
    start_gradient = arg.start_gradient, end_gradient = arg.end_gradient, end_change = arg.end_change, pos = arg.pos;
    shape = start_gradient.shape;
    return shape + ", ";
  };

  register_animation_handler(gradient_handler({
    hook_name: 'radialGradient',
    function_name: 'radial-gradient',
    parse_gradient: parse_radial_gradient,
    pre_stops_css: pre_stops_css_radial_gradient
  }));

}).call(this);
